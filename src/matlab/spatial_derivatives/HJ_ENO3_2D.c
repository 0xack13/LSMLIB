/*
 * File:        HJ_ENO3_2D.c
 * Copyright:   (c) 2005-2006 Kevin T. Chu
 * Revision:    $Revision: 1.10 $
 * Modified:    $Date: 2006/09/18 20:27:31 $
 * Description: MATLAB MEX-file for 2d, third-order plus and minus HJ ENO 
 */

/*=======================================================================
 *
 * HJ_ENO3_2D() computes the third-order plus and minus HJ ENO
 * approximation to grad(phi)
 *
 * Usage: [phi_x_plus, phi_y_plus, phi_x_minus, phi_y_minus] = ...
 *        HJ_ENO3_2D(phi, ghostcell_width, dX)
 *
 * Arguments:
 * - phi:              function on which to compute plus and minus
 *                       spatial derivative
 * - ghostcell_width:  number of ghostcells at boundary of
 *                       computational domain
 * - dX:               array containing the grid spacing
 *                       in coordinate directions
 *
 * Return values:
 * - phi_x_plus:       x-component of third-order, plus
 *                       HJ ENO derivative
 * - phi_y_plus:       y-component of third-order, plus
 *                       HJ ENO derivative
 * - phi_x_minus:      x-component of third-order, minus
 *                       HJ ENO derivative
 * - phi_y_minus:      y-component of third-order, minus
 *                       HJ ENO derivative
 *
 * NOTES:
 * - phi_x_plus, phi_y_plus, phi_x_minus and phi_y_minus have the
 *   same ghostcell width as phi.
 *
 * - All data arrays are assumed to be in the order generated by the
 *   MATLAB meshgrid() function.  That is, data corresponding to the
 *   point (x_i,y_j) is stored at index (j,i).  The output data arrays 
 *   will be returned with the same ordering as the input data arrays. 
 *
 *=======================================================================*/

#include "mex.h"
#include "matrix.h"
#include "lsm_spatial_derivatives2d.h"

/* Input Arguments */ 
#define PHI             (prhs[0])
#define GHOSTCELL_WIDTH (prhs[1])
#define DX              (prhs[2])

/* Output Arguments */ 
#define PHI_X_PLUS      (plhs[0])
#define PHI_Y_PLUS      (plhs[1])
#define PHI_X_MINUS     (plhs[2])
#define PHI_Y_MINUS     (plhs[3])


void mexFunction( int nlhs, mxArray *plhs[], 
		  int nrhs, const mxArray*prhs[] )
     
{ 
  double *phi_x_plus, *phi_x_minus, *phi_y_plus, *phi_y_minus;
  int ilo_grad_phi_gb, ihi_grad_phi_gb, jlo_grad_phi_gb, jhi_grad_phi_gb;
  double *phi; 
  int ilo_phi_gb, ihi_phi_gb, jlo_phi_gb, jhi_phi_gb;
  double *D1;
  int ilo_D1_gb, ihi_D1_gb, jlo_D1_gb, jhi_D1_gb;
  double *D2;
  int ilo_D2_gb, ihi_D2_gb, jlo_D2_gb, jhi_D2_gb;
  double *D3;
  int ilo_D3_gb, ihi_D3_gb, jlo_D3_gb, jhi_D3_gb;
  int ilo_fb, ihi_fb, jlo_fb, jhi_fb;
  double *dX;
  double dX_meshgrid_order[2];
  int ghostcell_width;
  int num_data_array_dims;
  
  /* Check for proper number of arguments */
  if (nrhs != 3) { 
    mexErrMsgTxt("Three required input arguments."); 
  } else if (nlhs > 4) {
    mexErrMsgTxt("Too many output arguments."); 
  } 
    
  /* Parameter Checks */
  num_data_array_dims = mxGetNumberOfDimensions(PHI);
  if (num_data_array_dims != 2) {
    mexErrMsgTxt("phi should be a 2 dimensional array."); 
  }

  /* Get ghostcell_width */
  ghostcell_width = mxGetPr(GHOSTCELL_WIDTH)[0];

  /* Get dX */
  dX = mxGetPr(DX);

  /* Change order of dX to match MATLAB meshgrid() order for grids. */
  dX_meshgrid_order[0] = dX[1];
  dX_meshgrid_order[1] = dX[0];

  /* Assign pointers for phi */
  phi = mxGetPr(PHI);
      
  /* Get size of phi data */
  ilo_phi_gb = 1;
  ihi_phi_gb = mxGetM(PHI);
  jlo_phi_gb = 1;
  jhi_phi_gb = mxGetN(PHI);

  /* Create matrices for plus and minus derivatives */
  ilo_grad_phi_gb = ilo_phi_gb;
  ihi_grad_phi_gb = ihi_phi_gb;
  jlo_grad_phi_gb = ilo_phi_gb;
  jhi_grad_phi_gb = jhi_phi_gb;
  PHI_X_PLUS = mxCreateDoubleMatrix(ihi_grad_phi_gb-ilo_grad_phi_gb+1,
                                    jhi_grad_phi_gb-jlo_grad_phi_gb+1,
                                    mxREAL);
  phi_x_plus = mxGetPr(PHI_X_PLUS); 
  PHI_Y_PLUS = mxCreateDoubleMatrix(ihi_grad_phi_gb-ilo_grad_phi_gb+1,
                                    jhi_grad_phi_gb-jlo_grad_phi_gb+1,
                                    mxREAL);
  phi_y_plus = mxGetPr(PHI_Y_PLUS); 
  PHI_X_MINUS = mxCreateDoubleMatrix(ihi_grad_phi_gb-ilo_grad_phi_gb+1,
                                    jhi_grad_phi_gb-jlo_grad_phi_gb+1,
                                    mxREAL);
  phi_x_minus = mxGetPr(PHI_X_MINUS); 
  PHI_Y_MINUS = mxCreateDoubleMatrix(ihi_grad_phi_gb-ilo_grad_phi_gb+1,
                                    jhi_grad_phi_gb-jlo_grad_phi_gb+1,
                                    mxREAL);
  phi_y_minus = mxGetPr(PHI_Y_MINUS); 

  /* Allocate scratch memory for undivided differences */
  ilo_D1_gb = ilo_phi_gb;
  ihi_D1_gb = ihi_phi_gb;
  jlo_D1_gb = ilo_phi_gb;
  jhi_D1_gb = jhi_phi_gb;
  D1 = (double*) malloc( sizeof(double)
                       * (ihi_D1_gb-ilo_D1_gb+1) 
                       * (jhi_D1_gb-jlo_D1_gb+1) );

  ilo_D2_gb = ilo_phi_gb;
  ihi_D2_gb = ihi_phi_gb;
  jlo_D2_gb = ilo_phi_gb;
  jhi_D2_gb = jhi_phi_gb;
  D2 = (double*) malloc( sizeof(double)
                       * (ihi_D2_gb-ilo_D2_gb+1) 
                       * (jhi_D2_gb-jlo_D2_gb+1) );

  ilo_D3_gb = ilo_phi_gb;
  ihi_D3_gb = ihi_phi_gb;
  jlo_D3_gb = ilo_phi_gb;
  jhi_D3_gb = jhi_phi_gb;
  D3 = (double*) malloc( sizeof(double)
                       * (ihi_D3_gb-ilo_D3_gb+1) 
                       * (jhi_D3_gb-jlo_D3_gb+1) );

  if ( (!D1) || (!D2) || (!D3) ) {
    if (D1) free(D1);
    if (D2) free(D2);
    if (D3) free(D3);
    mexErrMsgTxt("Unable to allocate memory for scratch data...aborting....");
  }

  /* Do the actual computations in a Fortran 77 subroutine */
  ilo_fb = ilo_phi_gb+ghostcell_width;
  ihi_fb = ihi_phi_gb-ghostcell_width;
  jlo_fb = jlo_phi_gb+ghostcell_width;
  jhi_fb = jhi_phi_gb-ghostcell_width;

  /* 
   * NOTE: ordering of data arrays from meshgrid() is (y,x), so order
   * derivative data arrays needs to be reversed.
   */
  LSM2D_HJ_ENO3(
    phi_y_plus, phi_x_plus, 
    &ilo_grad_phi_gb, &ihi_grad_phi_gb,
    &jlo_grad_phi_gb, &jhi_grad_phi_gb,
    phi_y_minus, phi_x_minus, 
    &ilo_grad_phi_gb, &ihi_grad_phi_gb,
    &jlo_grad_phi_gb, &jhi_grad_phi_gb,
    phi, 
    &ilo_phi_gb, &ihi_phi_gb, &jlo_phi_gb, &jhi_phi_gb, 
    D1,
    &ilo_D1_gb, &ihi_D1_gb, &jlo_D1_gb, &jhi_D1_gb, 
    D2,
    &ilo_D2_gb, &ihi_D2_gb, &jlo_D2_gb, &jhi_D2_gb, 
    D3,
    &ilo_D3_gb, &ihi_D3_gb, &jlo_D3_gb, &jhi_D3_gb, 
    &ilo_fb, &ihi_fb, &jlo_fb, &jhi_fb,
    &dX_meshgrid_order[0], &dX_meshgrid_order[1]);

  /* Deallocate scratch memory for undivided differences */
  free(D1);
  free(D2);
  free(D3);

  return;
}
